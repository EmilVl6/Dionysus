<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="description" content="Developer ≷ Drummer | If you don’t know who I am, then maybe your best course would be to Tread Lightly" />
  <title>Emil Vinod</title>
  <link rel="icon" href="favicon.ico">
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;600;700;800&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@600&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Caveat:wght@700&display=swap" rel="stylesheet">
  <script src="phraseology.js"></script>
</head>

<body>
  <div class="pixel-grid" aria-hidden="true"></div>
  <div id="page-wrap">
    <button id="color-btn" title="" aria-label="">
      <img src="favicon.png" alt="icon" class="color-btn-icon" />
    </button>
    <main class="center">
    <div class="scene" aria-hidden="true">
      <div class="banner">
        <div class="panel" data-index="1" data-text=""></div>
        <div class="panel" data-index="2" data-text=""></div>
        <div class="panel" data-index="3" data-text=""></div>
        <div class="panel" data-index="4" data-text=""></div>
        <div class="panel" data-index="5" data-text=""></div>
        <div class="panel" data-index="6" data-text=""></div>
        <div class="panel" data-index="7" data-text=""></div>
        <div class="panel" data-index="8" data-text=""></div>
        <div class="panel" data-index="9" data-text=""></div>
        <div class="panel" data-index="10" data-text=""></div>
        <div class="panel" data-index="11" data-text=""></div>
        <div class="panel" data-index="12" data-text=""></div>
        <div class="panel" data-index="13" data-text=""></div>
        <div class="panel" data-index="14" data-text=""></div>
        <div class="panel" data-index="15" data-text=""></div>
        <div class="panel" data-index="16" data-text=""></div>
        <div class="panel" data-index="17" data-text=""></div>
        <div class="panel" data-index="18" data-text=""></div>
        <div class="panel" data-index="19" data-text=""></div>
        <div class="panel" data-index="20" data-text=""></div>
        <div class="panel" data-index="21" data-text=""></div>
        <div class="panel" data-index="22" data-text=""></div>
        <div class="panel" data-index="23" data-text=""></div>
        <div class="panel" data-index="24" data-text=""></div>
      </div>
      <div class="screen"></div>
    </div>
      <div class="portrait" aria-hidden="true"><img src="Me.png" alt="" /></div>
      <div class="center-inner">
      <div class="pencil-intro">Hi I'm</div>
      </div>
      <h1 class="emil">Emil</h1>
      <h1 class="vinod">Vinod</h1>
      <p class="subtitle">Developer ≷ Drummer</p>
    </main>
  </div>
  <script>
    (function(){
      const colors = [
        '#ff6b35', '#bf7d5a', '#d55151', '#4e9294', '#c47085', '#ccb096', '#ca6d5c', '#aaa565'
      ];
      let idx = 0;
      const btn = document.getElementById('color-btn');
      const root = document.documentElement;
      function setBg(i){
        idx = i;
        root.style.setProperty('--bg', colors[idx]);
        btn.style.background = colors[(idx+1)%colors.length];
        btn.style.boxShadow = '0 2px 8px rgba(0,0,0,0.08)';
      }
      btn.addEventListener('click', function(){
        setBg((idx+1)%colors.length);
      });
      setBg(0);
    })();
    (function(){
      const el = document.querySelector('.center');
      if(!el) return;
      const inner = el.querySelector('.center-inner');
      if(!inner) return;
      el.style.overflow = 'hidden';
      function fit(){
        inner.style.transform = '';
        const neededH = inner.scrollHeight || inner.getBoundingClientRect().height || 0;
        const neededW = inner.scrollWidth  || inner.getBoundingClientRect().width  || 0;
        const availH = window.innerHeight || 0;
        const availW = window.innerWidth  || 0;
        const scaleH = neededH ? (availH / neededH) : 1;
        const scaleW = neededW ? (availW / neededW) : 1;
        const scale = Math.min(1, scaleH, scaleW);
        inner.style.transformOrigin = 'center center';
        inner.style.transform = `scale(${scale})`;
      }
      window.addEventListener('resize', fit);
      window.addEventListener('load', () => setTimeout(fit, 50));
      setTimeout(fit, 50);
      if (document.fonts && document.fonts.ready && typeof document.fonts.ready.then === 'function') {
        document.fonts.ready.then(fit);
      }

      (function(){
        const words = window.bgHeroWords || [];

        const phrases = words.map(s => String(s).trim());

        let phraseQueue = [];
        function shuffleQueue(){
          phraseQueue = phrases.slice();
          for(let i=phraseQueue.length-1;i>0;i--){
            const j = Math.floor(Math.random()*(i+1));
            [phraseQueue[i],phraseQueue[j]] = [phraseQueue[j],phraseQueue[i]];
          }
        }
        shuffleQueue();
        let queueIndex = 0;

        function pickNextPhrase(){
          if(phraseQueue.length === 0) shuffleQueue();
          if(queueIndex >= phraseQueue.length){
            shuffleQueue();
            queueIndex = 0;
          }
          return phraseQueue[queueIndex++];
        }

        const displayDelay = 4500;
        const fadeDuration = 450;
        const eraseDelay = 350;

        let typingTimers = [];
        function clearTimers(){ for(const t of typingTimers) clearTimeout(t); typingTimers = []; }

        function typeWord(word){
          clearTimers();
          const banner = document.querySelector('.banner');
          banner.dataset.lockAngle = '0';
          banner.style.animation = 'none';
          banner.style.transform = 'rotateY(0deg)';
          banner.offsetHeight; 
          banner.style.animation = 'rotate 24s infinite linear';
          document.querySelectorAll('.panel').forEach(p => p.setAttribute('data-text', ''));

          const typeSpeed = 60;
          const preCharDelay = 100;
          for(let i=0;i<word.length;i++){
            typingTimers.push(setTimeout(()=>{
              const text = word.slice(0, i) + '_';
              document.querySelectorAll('.panel').forEach(p => p.setAttribute('data-text', text));
            }, i * typeSpeed));

            typingTimers.push(setTimeout(()=>{
              const text = word.slice(0, i + 1);
              document.querySelectorAll('.panel').forEach(p => p.setAttribute('data-text', text));
            }, i * typeSpeed + preCharDelay));
          }

          typingTimers.push(setTimeout(() => {
            document.querySelectorAll('.panel').forEach(p => p.setAttribute('data-text', word));
          }, word.length * typeSpeed + preCharDelay));

          const total = word.length * typeSpeed + displayDelay;
          typingTimers.push(setTimeout(()=>{
            delete banner.dataset.lockAngle;
            typingTimers.push(setTimeout(()=>{ typeWord(pickNextPhrase()); }, eraseDelay));
          }, total));
        }

      setTimeout(()=>{ typeWord(pickNextPhrase()); }, 300);
      })();
    })();
  </script>
  <script>
    (function(){
      const cursor = document.createElement('div');
      cursor.className = 'cursor-circle';
      cursor.style.left = '-9999px';
      cursor.style.top = '-9999px';
      cursor.style.opacity = '0';
      document.body.appendChild(cursor);

      let mouseX = window.innerWidth/2, mouseY = window.innerHeight/2;
      let raf = null;
      let _seenFirstMove = false;

      function render(){
        cursor.style.left = mouseX + 'px';
        cursor.style.top = mouseY + 'px';
        raf = null;
      }

      window.addEventListener('mousemove', (e)=>{
        mouseX = e.clientX; mouseY = e.clientY;
        if(!_seenFirstMove){
          _seenFirstMove = true;
          cursor.style.opacity = '1';
        }
        
        if(!raf) raf = requestAnimationFrame(render);
      }, {passive:true});

        document.addEventListener('mouseleave', ()=>{
          cursor.style.opacity = '0';
        });
        document.addEventListener('mouseenter', ()=>{
          if(_seenFirstMove) cursor.style.opacity = '1';
        });

      window.addEventListener('mousedown', ()=>{ cursor.classList.add('active'); });
      window.addEventListener('mouseup', ()=>{ cursor.classList.remove('active'); });

      function bindHoverBig(selector){
        document.querySelectorAll(selector).forEach(el=>{
          el.addEventListener('mouseenter', ()=> cursor.classList.add('big'));
          el.addEventListener('mouseleave', ()=> cursor.classList.remove('big'));
        });
      }
      bindHoverBig('a');
      bindHoverBig('button');
      bindHoverBig('.btn');
      bindHoverBig('.folder-btn');

      if(('ontouchstart' in window) || navigator.maxTouchPoints > 0){
        cursor.style.display = 'none';
        document.body.style.cursor = 'auto';
      }
    })();

    (function(){
      const panels = document.querySelectorAll('.panel');
      const panelCount = panels.length;
      panels.forEach((panel, i) => {
        const index = i + 1;
        const angle = (360 / panelCount) * i;
        const hue = (360 / panelCount) * i;
        const left = 150 * i * -1;
        panel.style.setProperty('--angle', angle + 'deg');
        panel.style.setProperty('--hue', hue);
        panel.style.setProperty('--left', left + 'px');
      });
    })();
  </script>
  <script>
    (function(){
      function updateCarousel(){
        const root = document.documentElement;
        const panels = document.querySelectorAll('.panel');
        const panelCount = panels.length || 24;
        const vw = Math.max(window.innerWidth || 0, 320);
        const vh = Math.max(window.innerHeight || 0, 320);
        const portraitImg = document.querySelector('.portrait img');
        const imgH = portraitImg ? portraitImg.getBoundingClientRect().height : vh * 0.6;

        const radiusByWidth = vw * 0.55;
        const radiusByHeight = vh * 0.6;
        let radius = Math.max(240, Math.min(Math.max(radiusByWidth, radiusByHeight), 1400));

        const edgePadding = 24; 
        const panelWidth = 150; 
        const visibleWidth = 2 * radius + panelWidth;
        if(visibleWidth < vw - edgePadding) {
          radius = Math.max(radius, (vw - panelWidth - edgePadding) / 2);
        }

        const bottomPx = Math.round(vh * 0.15);

        root.style.setProperty('--carousel-radius', Math.round(radius) + 'px');
        root.style.setProperty('--carousel-bottom', bottomPx + 'px');
      }

      window.addEventListener('resize', updateCarousel);
      window.addEventListener('load', () => setTimeout(updateCarousel, 80));
      if (document.fonts && document.fonts.ready && typeof document.fonts.ready.then === 'function') {
        document.fonts.ready.then(updateCarousel);
      }
      updateCarousel();
    })();
  </script>
  <script>
    (function(){
      const GRID = {};
      const container = document.querySelector('.pixel-grid');
      if(!container) return;

      const FIXED_COLS = 80;
      const FIXED_ROWS = 80;
      const CELL_SIZE = 8;

      function buildFixedGrid(){
        const frag = document.createDocumentFragment();
        const total = FIXED_COLS * FIXED_ROWS;
        for(let i=0;i<total;i++){
          const d = document.createElement('div');
          d.className = 'pixel';
          frag.appendChild(d);
        }
        container.appendChild(frag);
        
        container.style.gridTemplateColumns = `repeat(${FIXED_COLS}, ${CELL_SIZE}px)`;
        container.style.gridTemplateRows = `repeat(${FIXED_ROWS}, ${CELL_SIZE}px)`;
        container.style.width = (FIXED_COLS * CELL_SIZE) + 'px';
        container.style.height = (FIXED_ROWS * CELL_SIZE) + 'px';
        container.style.willChange = 'transform';

        GRID.cols = FIXED_COLS;
        GRID.rows = FIXED_ROWS;
        GRID.cellSize = CELL_SIZE;
        GRID.container = container;
        GRID.elements = container.children;
      }

      let scaleRAF = null;
      function scaleGrid(){
        if(scaleRAF) return;
        scaleRAF = requestAnimationFrame(() => {
          const vw = window.innerWidth;
          const vh = window.innerHeight;
          const gridWidth = FIXED_COLS * CELL_SIZE;
          const gridHeight = FIXED_ROWS * CELL_SIZE;
          
          const scaleX = vw / gridWidth;
          const scaleY = vh / gridHeight;
          const scale = Math.max(scaleX, scaleY) * 1.1;
          
          container.style.transform = `scale(${scale})`;
          container.style.transformOrigin = 'center center';
          container.style.left = '50%';
          container.style.top = '50%';
          container.style.marginLeft = -(gridWidth / 2) + 'px';
          container.style.marginTop = -(gridHeight / 2) + 'px';
          
          scaleRAF = null;
        });
      }

      GRID._buffer = new Map();
      GRID._flushScheduled = false;
      function _flushBuffer(){
        GRID._flushScheduled = false;
        if(!GRID._buffer || GRID._buffer.size === 0) { GRID._buffer.clear(); return; }
        GRID._buffer.forEach((color, idx) => {
          const el = GRID.elements[idx];
          if(el) el.style.background = color;
        });
        GRID._buffer.clear();
      }
      function setPixel(x,y,color){
        if(!GRID.container) return false;
        if(x < 0 || y < 0 || x >= GRID.cols || y >= GRID.rows) return false;
        const idx = y * GRID.cols + x;
        GRID._buffer.set(idx, color || 'transparent');
        if(!GRID._flushScheduled){ GRID._flushScheduled = true; requestAnimationFrame(_flushBuffer); }
        return true;
      }

      function getPixel(x,y){
        if(!GRID.container) return null;
        if(x < 0 || y < 0 || x >= GRID.cols || y >= GRID.rows) return null;
        const idx = y * GRID.cols + x;
        const el = GRID.elements[idx];
        return el ? (el.style.background || null) : null;
      }

      function clearGrid(){
        if(!GRID.container) return;
        for(let i=0;i<GRID.elements.length;i++) GRID._buffer.set(i, 'transparent');
        if(!GRID._flushScheduled){ GRID._flushScheduled = true; requestAnimationFrame(_flushBuffer); }
      }

      window.pixelGrid = {
        setPixel, getPixel, clear: clearGrid,
        GRID
      };

      buildFixedGrid();
      scaleGrid();
      
      let resizeTimeout;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(scaleGrid, 100);
      });
    })();
  </script>
  <script>
    (function(){
      const bakedFiles = [
        './Baked/plasma.json',
        './Baked/life.json',
        './Baked/waves.json',
        './Baked/flow.json',
        './Baked/rain.json',
        './Baked/sand.json',
        './Baked/bars-radix.json'
      ];

      const liveFiles = [
        './Simulations/plasma.js',
        './Simulations/life.js',
        './Simulations/waves.js',
        './Simulations/flow.js',
        './Simulations/rain.js',
        './Simulations/sand.js',
        './Simulations/bars-radix.js'
      ];
      
      const api = { pixelGrid: window.pixelGrid, root: document.documentElement };
      let idx = 0;
      let currentStop = null;
      const runFor = 6000;
      let useBaked = true;

      async function runNext(){
        if(!window.pixelGrid) return;
        
        if(currentStop) { 
          try{ currentStop(); }catch(e){} 
          currentStop = null; 
        }
        
        const bakedFile = bakedFiles[idx % bakedFiles.length];
        const liveFile = liveFiles[idx % liveFiles.length];
        idx++;
        
        if(useBaked) {
          try{
            const response = await fetch(bakedFile);
            if(!response.ok) throw new Error('Baked file not found');
            const data = await response.json();
            
            if(data && data.frames){
              window.pixelGrid.clear();
              currentStop = playBaked(data, api);
            }
          }catch(e){ 
            console.log('Baked files not ready, using live simulation');
            useBaked = false;
            try{
              const mod = await import(liveFile);
              if(mod && typeof mod.default === 'function'){
                window.pixelGrid.clear();
                currentStop = mod.default(api) || null;
              }
            }catch(e2){
              console.warn('Failed to load simulation', e2);
            }
          }
        } else {
          try{
            const mod = await import(liveFile);
            if(mod && typeof mod.default === 'function'){
              window.pixelGrid.clear();
              currentStop = mod.default(api) || null;
            }
          }catch(e){
            console.warn('Failed to load simulation', e);
          }
        }
        
        setTimeout(runNext, runFor);
      }

      function playBaked(data, api) {
        const { pixelGrid } = api;
        let frame = 0;
        let running = true;
        let currentColor = getComputedStyle(document.documentElement).getPropertyValue('--bg').trim();
        
        const hexToRgb = (hex) => {
          const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
          } : null;
        };
        
        window.onColorChange = function(newColor) {
          currentColor = newColor;
          if(running && currentFrameData){
            const rgb = hexToRgb(currentColor);
            if(rgb) {
              pixelGrid.clear();
              for (const [key, hslColor] of Object.entries(currentFrameData)) {
                const match = hslColor.match(/hsl\(0, 0%, (\d+)%\)/);
                if(match) {
                  const lightness = parseInt(match[1]);
                  const alpha = (100 - lightness) / 100;
                  const [x, y] = key.split(',').map(Number);
                  pixelGrid.setPixel(x, y, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`);
                }
              }
            }
          }
        };

        let currentFrameData;
        function render() {
          if (!running) return;
          
          currentFrameData = data.frames[frame % data.frames.length];
          pixelGrid.clear();
          
          const rgb = hexToRgb(currentColor);
          if(rgb) {
            for (const [key, hslColor] of Object.entries(currentFrameData)) {
              const match = hslColor.match(/hsl\(0, 0%, (\d+)%\)/);
              if(match) {
                const lightness = parseInt(match[1]);
                const alpha = (100 - lightness) / 100;
                const [x, y] = key.split(',').map(Number);
                pixelGrid.setPixel(x, y, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`);
              }
            }
          }
          
          frame++;
          setTimeout(() => {
            if (running) requestAnimationFrame(render);
          }, 50);
        }

        requestAnimationFrame(render);
        return () => { 
          running = false;
          window.onColorChange = null;
        };
      }

      function tryStart(){
        if(window.pixelGrid && window.pixelGrid.GRID){ 
          runNext(); 
        } else { 
          setTimeout(tryStart, 200); 
        }
      }
      
      tryStart();
    })();
  </script>
  <script>
    (function(){
      const banner = document.querySelector('.banner');
      if(!banner) return;
      let needsFallback = false;
      if(banner.getAnimations){
        try{ needsFallback = banner.getAnimations().length === 0; }catch(e){ needsFallback = false; }
      } else {
        const cs = getComputedStyle(banner);
        needsFallback = (cs.animationName === 'none' || cs.webkitAnimationName === 'none');
      }
      if(!needsFallback) return;
      let angle = 0;
      let last = performance.now();
      const period = 24000;
      const degPerMs = -360 / period;
      function tick(now){
        if(banner.dataset.lockAngle !== undefined){
          const locked = Number(banner.dataset.lockAngle) || 0;
          angle = locked;
          banner.style.webkitTransform = `rotateY(${angle}deg)`;
          banner.style.transform = `rotateY(${angle}deg)`;
          last = now;
          requestAnimationFrame(tick);
          return;
        }
        const dt = now - last;
        last = now;
        angle = (angle + degPerMs * dt) % 360;
        banner.style.webkitTransform = `rotateY(${angle}deg)`;
        banner.style.transform = `rotateY(${angle}deg)`;
        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);
    })();
  </script>

</body>
</html>